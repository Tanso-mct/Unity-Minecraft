#pragma kernel GenerateFlatWorld
#pragma kernel DiamondSquareStep
#pragma kernel MeshGenerate

int CHUCK_SIZE;
int WORLD_SIZE;
int WORLD_HALF_SIZE;
int WORLD_HEIGHT;

RWStructuredBuffer<int> blocksID;

int VIEW_ORIGIN_X;
int VIEW_ORIGIN_Y;
int VIEW_ORIGIN_Z;
int RENDER_DISTANCE;

RWStructuredBuffer<int> counts;

RWStructuredBuffer<float3> meshVs;
RWStructuredBuffer<float2> meshUVs;
RWStructuredBuffer<int> meshTris;

int SOURCE_MESH_BLOCK_VS_INDEX;
int SOURCE_MESH_BLOCK_TRIS_INDEX;
int SOURCE_MESH_BLOCK_VS_SIZE;
int SOURCE_MESH_BLOCK_TRIS_SIZE;
RWStructuredBuffer<float3> sourceMeshBlockVs;
RWStructuredBuffer<float3> sourceMeshBlockUVs;
RWStructuredBuffer<float3> sourceMeshBlockTris;

[numthreads(8,8,8)]
void GenerateFlatWorld (uint3 id : SV_DispatchThreadID)
{
    int index = id.x + id.y * WORLD_HEIGHT + id.z * WORLD_HEIGHT * WORLD_SIZE;

    if (id.y == 0)
    {
        blocksID[index] = 1; // BEDROCK
    }
    else if (id.y == 1 || id.y == 2)
    {
        blocksID[index] = 2; // DIRT
    }
    else if (id.y == 3)
    {
        blocksID[index] = 3; // GRASS
    }
    else
    {
        blocksID[index] = 0; // AIR
    }
}

[numthreads(8,8,8)]
void DiamondSquareStep (uint3 id : SV_DispatchThreadID)
{
    int index = id.x + id.y * WORLD_HEIGHT + id.z * WORLD_HEIGHT * WORLD_SIZE;

    
}

int GetBlockVsCount(int id)
{
    switch (id)
    {
        case 1: // BEDROCK
        case 2: // DIRT
        case 3: // GRASS
            return SOURCE_MESH_BLOCK_VS_SIZE;
    }

    return 0;
}

int GetBlockTrisCount(int id)
{
    switch (id)
    {
        case 1: // BEDROCK
        case 2: // DIRT
        case 3: // GRASS
            return SOURCE_MESH_BLOCK_TRIS_SIZE;
    }

    return 0;
}

bool IsInWorldRange(int3 pos)
{
    if (
        pos.x >= 0 && pos.x < WORLD_SIZE &&
        pos.y >= 0 && pos.y < WORLD_HEIGHT &&
        pos.z >= 0 && pos.z < WORLD_SIZE
    ) return true;
    else return false;
}

bool CheckIsAir(int3 pos)
{
    if (IsInWorldRange(pos))
    {
        if (blocksID[pos.x + pos.y * WORLD_HEIGHT + pos.z * WORLD_HEIGHT * WORLD_SIZE] == 0)
        {
            return true;
        }
        
    }

    return false;
}

int3 ToCoordsIntConvert(int3 pos)
{
    return int3(pos.x - WORLD_HALF_SIZE, pos.y, pos.z - WORLD_HALF_SIZE);
}

[numthreads(8,8,8)]
void MeshGenerate (uint3 id : SV_DispatchThreadID)
{
    int3 voxel = int3(id.x + VIEW_ORIGIN_X, id.y + VIEW_ORIGIN_Y, id.z + VIEW_ORIGIN_Z);
    int index = voxel.x + voxel.y * WORLD_HEIGHT + voxel.z * WORLD_HEIGHT * WORLD_SIZE;

    // ブロックが描画範囲でかつ、空気ブロックでない場合処理を行う
    if (blocksID[index] != 0)
    {
        // ブロックの周囲に空気ブロックがあるかどうかを判定
        int3 checkPos = int3(voxel.x, voxel.y, voxel.z);

        // ブロックの周囲をチェック
        bool isNeedDraw = false;

        // 上下左右前後の6方向をチェック
        isNeedDraw = CheckIsAir(checkPos + int3(0, 1, 0)) ? true : isNeedDraw; // 上
        isNeedDraw = CheckIsAir(checkPos + int3(0, -1, 0)) ? true : isNeedDraw; // 下
        isNeedDraw = CheckIsAir(checkPos + int3(1, 0, 0)) ? true : isNeedDraw; // 右
        isNeedDraw = CheckIsAir(checkPos + int3(-1, 0, 0)) ? true : isNeedDraw; // 左
        isNeedDraw = CheckIsAir(checkPos + int3(0, 0, -1)) ? true : isNeedDraw; // 前
        isNeedDraw = CheckIsAir(checkPos + int3(0, 0, 1)) ? true : isNeedDraw; // 後

        // 描画対象のブロック情報を格納
        if (isNeedDraw)
        {
            InterlockedAdd(counts[0], 1);

            int thisVsIndex;
            InterlockedAdd(counts[1], GetBlockVsCount(blocksID[index]), thisVsIndex);

            int thisTrisIndex;
            InterlockedAdd(counts[2], GetBlockTrisCount(blocksID[index]), thisTrisIndex);

            // ブロックの座標を変換
            // int3 blockCoords = ToCoordsIntConvert(voxel);

            // int vsIndex = thisVsIndex;
            // for (int i = 0; i < SOURCE_MESH_BLOCK_VS_INDEX; i++)
            // {
            //     meshVs[vsIndex] = sourceMeshBlockVs[i] + float3(blockCoords.x, blockCoords.y, blockCoords.z);
            //     meshUVs[vsIndex] = sourceMeshBlockUVs[i];
            //     vsIndex++;
            // }

            // int trisIndex = thisTrisIndex;
            // for (int i = 0; i < SOURCE_MESH_BLOCK_TRIS_INDEX; i++)
            // {
            //     meshTris[trisIndex] = thisVsIndex + sourceMeshBlockTris[i];
            //     trisIndex++;
            // }
        }
    }
}
