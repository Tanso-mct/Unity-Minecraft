#pragma kernel GenerateFlatWorld
#pragma kernel DiamondSquareStep
#pragma kernel GetBlocksAdjacentAir
#pragma kernel MeshUpdate

int CHUCK_SIZE;
int WORLD_SIZE;
int WORLD_HALF_SIZE;
int WORLD_HEIGHT;

int SOURCE_MESH_VS_MAX;
int SOURCE_MESH_UVS_MAX;
int SOURCE_MESH_TRIS_MAX;

RWStructuredBuffer<int> blocksID;

int PLAYER_X;
int PLAYER_Y;
int PLAYER_Z;
int RENDER_DISTANCE;

RWStructuredBuffer<int> drawBlockCount;
RWStructuredBuffer<int4> drawBlockIndex;

RWStructuredBuffer<float3> meshVs;
RWStructuredBuffer<float2> meshUVs;
RWStructuredBuffer<int> meshTris;

RWStructuredBuffer<int> meshVsCount;
RWStructuredBuffer<int> meshUVsCount;
RWStructuredBuffer<int> meshTrisCount;

int SOURCE_MESH_BLOCK_VS_SIZE;
int SOURCE_MESH_BLOCK_UVS_SIZE;
int SOURCE_MESH_BLOCK_TRIS_SIZE;
RWStructuredBuffer<float3> sourceMeshBlockVs;
RWStructuredBuffer<float3> sourceMeshBlockUVs;
RWStructuredBuffer<float3> sourceMeshBlockTris;

[numthreads(8,8,8)]
void GenerateFlatWorld (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x + id.y * WORLD_HEIGHT + id.z * WORLD_HEIGHT * WORLD_SIZE;

    if (id.y == 0)
    {
        blocksID[index] = 1; // BEDROCK
    }
    else if (id.y == 1 || id.y == 2)
    {
        blocksID[index] = 2; // DIRT
    }
    else if (id.y == 3)
    {
        blocksID[index] = 3; // GRASS
    }
    else
    {
        blocksID[index] = 0; // AIR
    }
}

[numthreads(8,8,8)]
void DiamondSquareStep (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x + id.y * WORLD_HEIGHT + id.z * WORLD_HEIGHT * WORLD_SIZE;

    
}

int GetBlockVsCount(int id)
{
    switch (id)
    {
        case 1: // BEDROCK
        case 2: // DIRT
        case 3: // GRASS
            return SOURCE_MESH_BLOCK_VS_SIZE;
    }

    return 0;
}

int GetBlockUVsCount(int id)
{
    switch (id)
    {
        case 1: // BEDROCK
        case 2: // DIRT
        case 3: // GRASS
            return SOURCE_MESH_BLOCK_UVS_SIZE;
    }

    return 0;
}

int GetBlockTrisCount(int id)
{
    switch (id)
    {
        case 1: // BEDROCK
        case 2: // DIRT
        case 3: // GRASS
            return SOURCE_MESH_BLOCK_TRIS_SIZE;
    }

    return 0;
}

bool IsInWorldRange(int3 pos)
{
    if (
        pos.x >= 0 && pos.x < WORLD_SIZE &&
        pos.y >= 0 && pos.y < WORLD_HEIGHT &&
        pos.z >= 0 && pos.z < WORLD_SIZE
    ) return true;
    else return false;
}

bool CheckIsAir(int3 pos)
{
    if (IsInWorldRange(pos))
    {
        if (blocksID[pos.x + pos.y * WORLD_HEIGHT + pos.z * WORLD_HEIGHT * WORLD_SIZE] == 0)
        {
            return true;
        }
        
    }

    return false;
}

[numthreads(8,8,8)]
void GetBlocksAdjacentAir (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x + id.y * WORLD_HEIGHT + id.z * WORLD_HEIGHT * WORLD_SIZE;

    // 読み込み範囲をZ軸マイナスからプラス方向へ見たときの正面左下と、背面右上の座標を取得
    int3 worldOrigin = int3
    (
        PLAYER_X - RENDER_DISTANCE * CHUCK_SIZE, 
        PLAYER_Y - RENDER_DISTANCE * CHUCK_SIZE,
        PLAYER_Z - RENDER_DISTANCE * CHUCK_SIZE
    );

    int3 worldOpposite = int3
    (
        PLAYER_X + RENDER_DISTANCE * CHUCK_SIZE, 
        PLAYER_Y + RENDER_DISTANCE * CHUCK_SIZE,
        PLAYER_Z + RENDER_DISTANCE * CHUCK_SIZE
    );

    // それぞれワールドの範囲外の場合は、範囲内に収める
    worldOrigin.x = clamp(worldOrigin.x, 0, WORLD_SIZE - 1);
    worldOrigin.y = clamp(worldOrigin.y, 0, WORLD_HEIGHT - 1);
    worldOrigin.z = clamp(worldOrigin.z, 0, WORLD_SIZE - 1);

    worldOpposite.x = clamp(worldOpposite.x, 0, WORLD_SIZE - 1);
    worldOpposite.y = clamp(worldOpposite.y, 0, WORLD_HEIGHT - 1);
    worldOpposite.z = clamp(worldOpposite.z, 0, WORLD_SIZE - 1);

    // ブロックが描画範囲でかつ、空気ブロックでない場合処理を行う
    if (id.x >= worldOrigin.x && id.x <= worldOpposite.x &&
        id.y >= worldOrigin.y && id.y <= worldOpposite.y &&
        id.z >= worldOrigin.z && id.z <= worldOpposite.z &&
        blocksID[index] != 0
    ){
        // ブロックの周囲に空気ブロックがあるかどうかを判定
        int3 checkPos = int3(id.x, id.y, id.z);

        // ブロックの周囲をチェック
        bool isNeedDraw = false;

        // 上下左右前後の6方向をチェック
        isNeedDraw = CheckIsAir(checkPos + int3(0, 1, 0)) ? true : isNeedDraw; // 上
        isNeedDraw = CheckIsAir(checkPos + int3(0, -1, 0)) ? true : isNeedDraw; // 下
        isNeedDraw = CheckIsAir(checkPos + int3(1, 0, 0)) ? true : isNeedDraw; // 右
        isNeedDraw = CheckIsAir(checkPos + int3(-1, 0, 0)) ? true : isNeedDraw; // 左
        isNeedDraw = CheckIsAir(checkPos + int3(0, 0, -1)) ? true : isNeedDraw; // 前
        isNeedDraw = CheckIsAir(checkPos + int3(0, 0, 1)) ? true : isNeedDraw; // 後

        // 描画対象のブロック情報を格納
        if (isNeedDraw)
        {
            uint blockIndex;
            InterlockedAdd(drawBlockCount[0], 1, blockIndex);

            uint vsIndex;
            InterlockedAdd(meshVsCount[0], GetBlockVsCount(blocksID[index]), vsIndex);

            uint uvsIndex;
            InterlockedAdd(meshUVsCount[0], GetBlockUVsCount(blocksID[index]), uvsIndex);

            uint trisIndex;
            InterlockedAdd(meshTrisCount[0], GetBlockTrisCount(blocksID[index]), trisIndex);

            drawBlockIndex[blockIndex].x = index;
            drawBlockIndex[blockIndex].y = vsIndex;
            drawBlockIndex[blockIndex].z = uvsIndex;
            drawBlockIndex[blockIndex].w = trisIndex;
        }
    }
}

[numthreads(8,8,8)]
void MeshUpdate (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x + id.y * WORLD_HEIGHT + id.z * WORLD_HEIGHT * WORLD_SIZE;
}
