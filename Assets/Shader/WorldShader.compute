#pragma kernel MeshGenerate
#pragma kernel BlockUpdate
#pragma kernel RaycastAtBlock

int CHUCK_SIZE;
int WORLD_SIZE;
int WORLD_HALF_SIZE;
int WORLD_HEIGHT;

RWStructuredBuffer<int> blocksID;

int VIEW_ORIGIN_X;
int VIEW_ORIGIN_Y;
int VIEW_ORIGIN_Z;
int RENDER_DISTANCE;

RWStructuredBuffer<int> counts;

RWStructuredBuffer<float3> meshVs;
RWStructuredBuffer<float2> meshUVs;
RWStructuredBuffer<int> meshTris;

float TEXTURE_BLOCK_TILE_U;
float TEXTURE_BLOCK_TILE_V;

int SOURCE_MESH_BLOCK_FACE_COUNT;
int SOURCE_MESH_BLOCK_VS_INDEX;
int SOURCE_MESH_BLOCK_TRIS_INDEX;
int SOURCE_MESH_BLOCK_FRONT_FACES;
int SOURCE_MESH_BLOCK_BACK_FACES;
int SOURCE_MESH_BLOCK_LEFT_FACES;
int SOURCE_MESH_BLOCK_RIGHT_FACES;
int SOURCE_MESH_BLOCK_TOP_FACES;
int SOURCE_MESH_BLOCK_BOTTOM_FACES;

int SOURCE_MESH_GRASS_FACE_COUNT;
int SOURCE_MESH_GRASS_VS_INDEX;
int SOURCE_MESH_GRASS_TRIS_INDEX;
int SOURCE_MESH_GRASS_FRONT_FACES;
int SOURCE_MESH_GRASS_BACK_FACES;
int SOURCE_MESH_GRASS_LEFT_FACES;
int SOURCE_MESH_GRASS_RIGHT_FACES;
int SOURCE_MESH_GRASS_TOP_FACES;
int SOURCE_MESH_GRASS_BOTTOM_FACES;

int SOURCE_MESH_STAIRS_FACE_COUNT;
int SOURCE_MESH_STAIRS_VS_INDEX;
int SOURCE_MESH_STAIRS_TRIS_INDEX;
int SOURCE_MESH_STAIRS_FRONT_FACES;
int SOURCE_MESH_STAIRS_BACK_FACES;
int SOURCE_MESH_STAIRS_LEFT_FACES;
int SOURCE_MESH_STAIRS_RIGHT_FACES;
int SOURCE_MESH_STAIRS_TOP_FACES;
int SOURCE_MESH_STAIRS_BOTTOM_FACES;

RWStructuredBuffer<float3> sourceMeshVs;
RWStructuredBuffer<float2> sourceMeshUVs;
RWStructuredBuffer<int> sourceMeshTris;

bool IsInWorldRange(int3 pos)
{
    if (
        pos.x >= 0 && pos.x < WORLD_SIZE &&
        pos.y >= 0 && pos.y < WORLD_HEIGHT &&
        pos.z >= 0 && pos.z < WORLD_SIZE
    ) return true;
    else return false;
}

int CheckIsAir(int3 pos)
{
    if (IsInWorldRange(pos))
    {
        if (blocksID[pos.x + pos.y * WORLD_SIZE + pos.z * WORLD_HEIGHT * WORLD_SIZE] == 0)
        {
            return 1;
        }
    }

    return 0;
}

float3 ToCoordsIntConvert(int3 pos)
{
    return float3((float)pos.x - WORLD_HALF_SIZE, (float)pos.y, (float)pos.z - WORLD_HALF_SIZE);
}

float2 GetUVFromID(int blockId)
{
    float2 rtValue = float2
    (
        (blockId - 1) % 5 * TEXTURE_BLOCK_TILE_U, 
        (int)((blockId - 1) / 5) * TEXTURE_BLOCK_TILE_V
    );

    return rtValue;
}

int GetFaceCount(int blockId)
{
    switch (blockId)
    {
        case 1: // BEDROCK
        case 2: // DIRT
            return SOURCE_MESH_BLOCK_FACE_COUNT;

        case 3: // GRASS_TOP
        case 4: // GRASS_SIDE
        case 5: // GRASS_BOTTOM
            return SOURCE_MESH_GRASS_FACE_COUNT;
    }

    return 0;
}

int GetVsIndex(int blockId)
{
    switch (blockId)
    {
        case 1: // BEDROCK
        case 2: // DIRT
            return SOURCE_MESH_BLOCK_VS_INDEX;

        case 3: // GRASS_TOP
        case 4: // GRASS_SIDE
        case 5: // GRASS_BOTTOM
            return SOURCE_MESH_GRASS_VS_INDEX;
    }

    return 0;
}

int GetTrisIndex(int blockId)
{
    switch (blockId)
    {
        case 1: // BEDROCK
        case 2: // DIRT
            return SOURCE_MESH_BLOCK_TRIS_INDEX;

        case 3: // GRASS_TOP
        case 4: // GRASS_SIDE
        case 5: // GRASS_BOTTOM
            return SOURCE_MESH_GRASS_TRIS_INDEX;
    }

    return 0;
}

int GetFaces(int faceType, int frontFaces, int backFaces, int leftFaces, int rightFaces, int topFaces, int bottomFaces)
{
    switch (faceType)
    {
        case 0: return frontFaces;
        case 1: return backFaces;
        case 2: return leftFaces;
        case 3: return rightFaces;
        case 4: return topFaces;
        case 5: return bottomFaces;
    }

    return 0;
}

int GetAmountOfFaces(int blockId, int faceType)
{
    switch (blockId)
    {
        case 1: // BEDROCK
        case 2: // DIRT
            return GetFaces
            (
                faceType, 
                SOURCE_MESH_BLOCK_FRONT_FACES, 
                SOURCE_MESH_BLOCK_BACK_FACES, 
                SOURCE_MESH_BLOCK_LEFT_FACES, 
                SOURCE_MESH_BLOCK_RIGHT_FACES, 
                SOURCE_MESH_BLOCK_TOP_FACES, 
                SOURCE_MESH_BLOCK_BOTTOM_FACES
            );

        case 3: // GRASS_TOP
        case 4: // GRASS_SIDE
        case 5: // GRASS_BOTTOM
            return GetFaces
            (
                faceType, 
                SOURCE_MESH_GRASS_FRONT_FACES, 
                SOURCE_MESH_GRASS_BACK_FACES, 
                SOURCE_MESH_GRASS_LEFT_FACES, 
                SOURCE_MESH_GRASS_RIGHT_FACES, 
                SOURCE_MESH_GRASS_TOP_FACES, 
                SOURCE_MESH_GRASS_BOTTOM_FACES
            );
    }

    return 0;
}

[numthreads(8,8,8)]
void MeshGenerate (uint3 id : SV_DispatchThreadID)
{
    int3 voxel = int3(id.x + VIEW_ORIGIN_X, id.y + VIEW_ORIGIN_Y, id.z + VIEW_ORIGIN_Z);
    int index = voxel.x + voxel.y * WORLD_SIZE + voxel.z * WORLD_HEIGHT * WORLD_SIZE;

    // ブロックが描画範囲でかつ、空気ブロックでない場合処理を行う
    if (blocksID[index] != 0)
    {
        // 上下左右前後の6方向をチェック
        int isTopNeedDraw = CheckIsAir(voxel + int3(0, 1, 0));
        int isBottomNeedDraw = CheckIsAir(voxel + int3(0, -1, 0));
        int isLeftNeedDraw = CheckIsAir(voxel + int3(-1, 0, 0));
        int isRightNeedDraw = CheckIsAir(voxel + int3(1, 0, 0));
        int isFrontNeedDraw = CheckIsAir(voxel + int3(0, 0, -1));
        int isBackNeedDraw = CheckIsAir(voxel + int3(0, 0, 1));

        // どれか一つでも空気ブロックがあれば描画対象とする
        int isNeedDraw = isTopNeedDraw + isBottomNeedDraw + isLeftNeedDraw + isRightNeedDraw + isFrontNeedDraw + isBackNeedDraw;

        int drawFaceAmount = 0;
        drawFaceAmount += GetAmountOfFaces(blocksID[index], 0) * isFrontNeedDraw;
        drawFaceAmount += GetAmountOfFaces(blocksID[index], 1) * isBackNeedDraw;
        drawFaceAmount += GetAmountOfFaces(blocksID[index], 2) * isLeftNeedDraw;
        drawFaceAmount += GetAmountOfFaces(blocksID[index], 3) * isRightNeedDraw;
        drawFaceAmount += GetAmountOfFaces(blocksID[index], 4) * isTopNeedDraw;
        drawFaceAmount += GetAmountOfFaces(blocksID[index], 5) * isBottomNeedDraw;

        // 描画対象のブロック情報を格納
        if (isNeedDraw > 0)
        {
            InterlockedAdd(counts[0], 1);

            int thisVsIndex;
            InterlockedAdd(counts[1], drawFaceAmount * 4, thisVsIndex);

            int thisTrisIndex;
            InterlockedAdd(counts[2], drawFaceAmount * 6, thisTrisIndex);

            int vsIndex = thisVsIndex;
            int trisIndex = thisTrisIndex;

            int meshFaceCount = GetFaceCount(blocksID[index]);
            int meshVsIndex = GetVsIndex(blocksID[index]);
            int meshTrisIndex = GetTrisIndex(blocksID[index]);
            
            int totalFaceAmount = GetAmountOfFaces(blocksID[index], 0);
            int faceType = 0;
            for (int i = 0; i < meshFaceCount; i++)
            {
                int nowDrawing = 0;

                if (faceType == 0) nowDrawing = isFrontNeedDraw;
                else if (faceType == 1) nowDrawing = isBackNeedDraw;
                else if (faceType == 2) nowDrawing = isLeftNeedDraw;
                else if (faceType == 3) nowDrawing = isRightNeedDraw;
                else if (faceType == 4) nowDrawing = isTopNeedDraw;
                else if (faceType == 5) nowDrawing = isBottomNeedDraw;

                if (i == totalFaceAmount - 1)
                {
                    faceType++;
                    totalFaceAmount += GetAmountOfFaces(blocksID[index], faceType);
                }

                if (nowDrawing == 1)
                {
                    // ブロックの座標を変換
                    float3 blockCoords = ToCoordsIntConvert(voxel);

                    for (int j = 0; j < 4; j++)
                    {
                        meshVs[vsIndex] = 
                        sourceMeshVs[meshVsIndex + i * 4 + j] + 
                        float3(blockCoords.x, blockCoords.y, blockCoords.z);

                        float2 uvDiff = GetUVFromID(blocksID[index]);

                        meshUVs[vsIndex] = sourceMeshUVs[meshVsIndex + i * 4 + j] + uvDiff;

                        vsIndex++;
                    }

                    for (int j = 0; j < 6; j++)
                    {
                        meshTris[trisIndex] = thisVsIndex + sourceMeshTris[meshTrisIndex + i * 6 + j];
                        trisIndex++;
                    }

                    thisVsIndex += 4;
                }
            }
        }
    }
}

int TARGET_BLOCK_X;
int TARGET_BLOCK_Y;
int TARGET_BLOCK_Z;

int GENERATE_BLOCK_ID;
[numthreads(1,1,1)]
void BlockUpdate (uint3 id : SV_DispatchThreadID)
{
    int index = TARGET_BLOCK_X + TARGET_BLOCK_Y * WORLD_SIZE + TARGET_BLOCK_Z * WORLD_HEIGHT * WORLD_SIZE;
    blocksID[index] = GENERATE_BLOCK_ID;
}

float RAY_SIZE;
float RAY_ORIGIN_X;
float RAY_ORIGIN_Y;
float RAY_ORIGIN_Z;

float RAY_DIRECTION_X;
float RAY_DIRECTION_Y;
float RAY_DIRECTION_Z;

float RAY_LENGTH;

RWStructuredBuffer<float4> raycastBlocks;

[numthreads(8,1,1)]
void RaycastAtBlock (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;

    float3 rayPos;
    rayPos.x = RAY_ORIGIN_X + (RAY_DIRECTION_X * RAY_LENGTH) * ((float)index / (float)RAY_SIZE);
    rayPos.y = RAY_ORIGIN_Y + (RAY_DIRECTION_Y * RAY_LENGTH) * ((float)index / (float)RAY_SIZE);
    rayPos.z = RAY_ORIGIN_Z + (RAY_DIRECTION_Z * RAY_LENGTH) * ((float)index / (float)RAY_SIZE);

    int3 blockPos = int3(rayPos);
    float3 rayFloatPart = rayPos - float3(int3(rayPos));
    
    if (rayFloatPart.x >= 0.5) blockPos.x += 1;
    if (rayFloatPart.y >= 0.5) blockPos.y += 1;
    if (rayFloatPart.z >= 0.5) blockPos.z += 1;

    raycastBlocks[index].x = blockPos.x;
    raycastBlocks[index].y = blockPos.y;
    raycastBlocks[index].z = blockPos.z;
    raycastBlocks[index].w = blocksID[blockPos.x + blockPos.y * WORLD_SIZE + blockPos.z * WORLD_HEIGHT * WORLD_SIZE];
}

RWStructuredBuffer<float3> boxPos; // ボックスの底面の中心座標
RWStructuredBuffer<float3> boxSize; // ボックスのサイズ
RWStructuredBuffer<float> hitSide; // ヒットした面 543210の6桁の数値でそれぞれの桁が 5:前 4:後 3:左 2:右 1:上 0:下

[numthreads(8,1,1)]
void GetHitBlock (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;

    float3 boxOrigin = boxPos[index];
    boxOrigin.x -= boxSize[index].x / 2;
    boxOrigin.z -= boxSize[index].z / 2;

    float3 boxOpposite = boxPos[index];
    boxOpposite.x += boxSize[index].x / 2;
    boxOpposite.y += boxSize[index].y;
    boxOpposite.z += boxSize[index].z / 2;
    
}
